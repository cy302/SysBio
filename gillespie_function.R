#x1 is mRNA which has low amount, 10
#x2 is protein which is abundant, 1000
##### Initialisation #####
library(parallel)
set.seed(2018)

#initial x1 and x2
# lambda1 <- seq(1,20,by=1)
# lambda2 <- seq(0,500,by=50)[-1]
# beta1 <- seq(1,20,by=1)
# beta2 <- seq(2,30,by=2)

#This function creates combination of 500 different parameters
createParameters <- function(l1_min, l1_max, l2_min, l2_max,
                             b1_min,b1_max, b2_min, b2_max, number=40){
  lambda1 <- seq(l1_min,l1_max,by=2)
  lambda2 <- seq(l2_min,l2_max,by=2)
  beta1 <- seq(b1_min,b1_max,by=2)
  beta2 <- seq(b2_min,b2_max,by=2)
  check_dup <- c(1,1)
  while(any(table(check_dup)>1)){
    parameter_matrix <- sapply(1:number,function(x){
      c(sample(lambda1,1),sample(lambda2,1),sample(beta1,1),sample(beta2,1))
    })
    parameter_matrix <- t(parameter_matrix)
    check_dup <- apply(parameter_matrix,1,function(x)paste(x,collapse = "_"))
  }
  parameters <- as.data.frame(parameter_matrix)
  colnames(parameters) <- c("lambda1","lambda2","beta1","beta2")
  parameters_list <- split(parameters, seq(nrow(parameters)))
  parameters_list
}

# Core function
gillespie <- function(x1, x2, iteration, lambda1, beta1,
                      lambda2, beta2, check_interval=100000, ar_func=function(x){1}){
  
  ## ar_func: autorepression function of x2, the birth rate of x1
  time_keeper <- x1_storage <- x2_storage <- rep(0, iteration)
  
  time_keeper[1] <- 0
  x1_storage[1] <- x1
  x2_storage[1] <- x2
  
  epoch_test_1 <- epoch_test_2 <- c()
  indi <- FALSE
  
  #calculate rate of change in x1 and x2, both birth and death
  for (i in 2:iteration){
    x1_birth <- lambda1 * ar_func(x2)
    x1_death <- x1 * beta1
    x2_birth <- x1 * lambda2
    x2_death <- x2 * beta2

    
    #total rate of change of x_1 and x_2
    Tot_rate <- sum(x1_birth, x1_death, x2_birth, x2_death)
    time_keeper[i] <- rexp(1,Tot_rate) + time_keeper[i-1]
    
    #Choose a event
    u_event <- runif(1,0,1)
    stick_frac <- c(0, x1_birth, x1_death, x2_birth, x2_death)
    stick <- cumsum(stick_frac)/Tot_rate
    u_event <- runif(1)
    which_event <- tail(which(u_event > stick), 1) #Choose the falling region
    
    #Execute an event
    if (which_event == 1)x1 <- x1 + 1  #x1_birth
    if (which_event == 2)x1 <- x1 - 1  #x1_death
    if (which_event == 3)x2 <- x2 + 1  #x2_birth
    if (which_event == 4)x2 <- x2 - 1  #x2_death
    
    
    #Store values
    x1_storage[i] <- x1
    x2_storage[i] <- x2
    
    # if (indi){
    #   break
    #   message("The random walk has reached stationarity at iteration: ", i)
    # }
  }
  
  time_duration <- tail(time_keeper, iteration-1) - head(time_keeper, iteration)
  x1_average <- weighted.mean(x=head(x1_storage, iteration-1), w=time_duration)
  x2_average <- weighted.mean(x=head(x2_storage, iteration-1), w=time_duration)
  
  R_plus_1 <- lambda1 * ar_func(x2_average)
  R_minus_1 <- beta1 * x1_average
  R_plus_2 <- lambda2 * x1_average
  R_minus_2 <- beta2 * x2_average
  
  relative_R1_diff <- abs(R_plus_1-R_minus_1)/mean(c(R_plus_1, R_minus_1))
  relative_R2_diff <- abs(R_plus_2-R_minus_2)/mean(c(R_plus_2, R_minus_2))
  
  indi <- (relative_R1_diff && relative_R2_diff<0.01)
  
  
  #Output result
  result <- cbind.data.frame(time = time_keeper, x1 = x1_storage, x2 = x2_storage,
                             R_plus_x1 = r_plus_1, R_minus_x1 = r_minus_1,
                             R_plus_x2 = r_plus_2, R_minus_x2 = r_minus_2)
  result <- head(result, i)
  epochs <- cbind.data.frame(x1 = epoch_test_1, x2 = epoch_test_2)
  gc()
  print("done")
  return(list("parm" = c(beta1=beta1, beta2=beta2, 
                         lambda1=lambda1, lambda2=lambda2), 
              result = result, "epochs" = epochs, 
              "check_interval" = check_interval, "stationary_reached"=indi, 
              "Relative_diff"=c(relative_R1_diff, relative_R2_diff)))
}

#create parameters
# parameters1 <- createParameters(50, 100, 300, 500, 2, 10, 30, 50, number=40) #extrinsic dominance
# parameters2 <- createParameters(50, 100, 300, 500, 2, 30, 2, 30, number=40) #similar
# parameters3 <- createParameters(50, 100, 50, 100, 10, 20, 50, 80, number=40) #intrinsic dominance
parameters <- createParameters(2,200,2,200,2,200,2,200, number=250)
#parameters <- c(parameters1,parameters2,parameters3)
#names(parameters) <- 1:500

#parameters <- list(data.frame(lambda1=100,lambda2=50, beta1=10, beta2=200))

#run simulation 500 times, with different parameters
system.time(all_parm_result <- mclapply(parameters,function(x){
  gillespie(100,100, 5e5, x$lambda1, x$beta1, x$lambda2, x$beta2, 50000)}
  ,mc.cores=7L))

tot_iteration <- nrow(all_parm_result[[1]]$result)
plot(all_parm_result[[1]]$result$time[seq(1,tot_iteration,len=10000)],
     all_parm_result[[1]]$result$x2[seq(1,tot_iteration,len=10000)],type="l",ylim=c(0,30))

tail(all_parm_result[[1]]$result$x1,10000)
noise_calculator <- function(dat1, dat2, parm){
  tau1 <- 1/parm["beta1"]
  tau2 <- 1/parm["beta2"]
  mRNA_noise <- 1/mean(dat1)
  ex_noise <- mRNA_noise + tau1/(tau1+tau2)
  in_noise <- 1/mean(dat2)
  names(ex_noise) <- NULL
  return(c("Extrinsic" = ex_noise, "Intrinsic" = in_noise))
}

all_noise <- lapply(all_parm_result,function(x){
  df_length <- nrow(x$result)
  check_range <- (df_length - x$check_interval):df_length
  check_data <- x$result[check_range,]
  noise_calculator(check_data$x1,check_data$x2,x$parm)
})

all_noise <- do.call(rbind.data.frame,all_noise)
names(all_noise) <- c("Extrinsic", "Intrinsic")
plot_col <- rep("black",length(all_noise$Extrinsic))

plot_col[all_noise$Extrinsic/all_noise$Intrinsic > 1.5] <- "blue"

plot_col[all_noise$Intrinsic/all_noise$Extrinsic > 1.5] <- "green"

R_diff <- check_simulation(all_parm_result)
coverged_loc <- which(R_diff[[1]]<0.01&R_diff[[2]]<0.01)
plot_col[coverged_loc] <- "red"

pdf("/home/skllr-b/Desktop/Temp/sba1/noise_plot_2B.pdf",width=7,height=7)
plot(log10(all_noise),col=plot_col,
     ylim=c(-2.5,2),xlim=c(-0.5,0.5),
     ylab="log10(Intrinsic noise)",
     xlab="log10(Extrinsic noise)",pch=19,cex=0.5)
lines(c(-1000,1000),c(-1000,1000))
legend("topleft", legend=c("Dominated by intrinsic noise",
                           "Dominated by extrinsic noise",
                           "In between",
                           "Reached stationery state"),
       col=c("black","green","blue","red"),pch=19)
dev.off()


check_simulation <- function(simulation_results, check_interval = 100000){
  
  relative_diff_x1 <- sapply(simulation_results, function(x){
    last_dat <- as.data.frame(tail(x$result,check_interval))
    abs(mean(last_dat$R_plus_x1) - mean(last_dat$R_minus_x1))/
      mean(c(mean(last_dat$R_plus_x1),mean(last_dat$R_minus_x1)))
  })
  
  relative_diff_x2 <- sapply(simulation_results, function(x){
    last_dat <- as.data.frame(tail(x$result,check_interval))
    abs(mean(last_dat$R_plus_x2) - mean(last_dat$R_minus_x2))/
      mean(c(mean(last_dat$R_plus_x2),mean(last_dat$R_minus_x2)))
  })
  list(relative_diff_x1, relative_diff_x2)
  
}
pdf("/home/skllr-b/Desktop/Temp/sba1/flux_error.pdf",width=10,height=5)
par(mfrow=c(1,2),mar=c(4,5,1,1))
hist(log10(R_diff[[1]]),breaks=100,xlab="log10(Relative error in flux balance relation for x1)",main=""); box()
abline(v=log10(0.01),col="red")
hist(log10(R_diff[[2]]),breaks=100,xlab="log10(Relative error in flux balance relation for x2)",main=""); box()
abline(v=log10(0.01),col="red")
dev.off()
last_stable_dat <- tail(all_parm_result[[coverged_loc[3]]]$result,200000)
nrow(all_parm_result[[216]]$result)
last_stable_x1 <- last_stable_dat$x1
last_stable_x2 <- last_stable_dat$x2
last_stable_time <- last_stable_dat$time
pdf("/home/skllr-b/Desktop/Temp/sba1/example_plot_2D.pdf",width=10,height=5)
par(mfrow=c(1,2),mar=c(4,5,1,1))
plot(last_stable_time, last_stable_x1,type="l",lwd=1,
     xlab="time",ylab="number of x1")
plot(last_stable_time, last_stable_x2,type="l",col="red",lwd=1,
     xlab="time",ylab="number of x2")
dev.off()

pdf("/home/skllr-b/Desktop/Temp/sba1/example_plot_zoom_2D.pdf",width=8,height=5)
par(mar=c(4,5,1,5))
plot(last_stable_time[100000:150000], last_stable_x1[100000:150000],
     type="l",lwd=1, xlab="Time",ylab="The number of x1")
par(new=TRUE)
plot(last_stable_time[100000:150000], last_stable_x2[100000:150000],type="l",col="red",lwd=1,yaxt="n",xlab="",ylab="")
axis(4,col="red")
mtext("The number of x2", side=4, line=3, col="red")
legend("topleft", legend=c("x1","x2"),col=c("black","red"),lty=1,)
dev.off()


##checks how do the simulated and theoretical etas differ. Also plots out
##simulated vs theoretical etas.
check_accuracy <- function(simulation_results){
    eta11 <- eta12 <- eta22 <- rep(0, 100)
    eta11_analytic <- eta12_analytic <- eta22_analytic <- rep(0, 100)
    for (i in 1:100){
        result <- simulation_results[[i]]
        x1 <- result$x1
        x2 <- result$x2
        tau1 <- 1/result$parm["beta1"]
        tau2 <- 1/result$parm["beta2"]
        var_x1 <- var(x1)
        var_x2 <- var(x2)
        cov_x1_x2 <- cov(x1, x2)
        x1_mean <- mean(x1)
        x2_mean <- mean(x2)
        eta11[i] <- var_x1/(x1_mean^2)
        eta22[i] <- var_x2/(x2_mean^2)
        eta12[i] <- cov_x1_x2/(x1_mean*x2_mean)
        eta11_analytic[i] <- 1/x1_mean
        eta12_analytic[i] <- tau1/((tau1+tau2)*x1_mean)
        eta22_analytic[i] <- 1/x2_mean + tau1/((tau1+tau2)*x1_mean)
    }
    dev11 <- abs(eta11 - eta11_analytic)/eta11_analytic
    dev12 <- abs(eta12 - eta12_analytic)/eta12_analytic
    dev22 <- abs(eta22 - eta22_analytic)/eta22_analytic
    pdf("plot2B_2.pdf", width = 8, height = 6)
    par(mfrow=c(1, 3))
    plot(hist(dev11), main="relative deviation of eta11")
    plot(hist(dev12), main="relative deviation of eta12")
    plot(hist(dev22), main="relative deviation of eta22")
    dev.off()
    eta <- data.frame(cbind(eta11, eta12, eta22))
    names(eta) <- c("eta11", "eta12", "eta22")
    eta_analytic <- data.frame(cbind(eta11_analytic, eta12_analytic, eta22_analytic))
    names(eta_analytic) <- c("eta11", "eta12", "eta22")
    return(list("observedEta" = eta, "theoreticalEta" = eta_analytic))
}


## 2.C
D <- check_accuracy(simulation_results)
observed_eta22 <- D$observedEta$eta22
theoretical_eta22 <- D$theoreticalEta$eta22

noise_plot <- function(observed, theoretical){
    pdf("2Cplot.pdf", width = 8, height = 6)
    plot(observed, theoretical, type="l", xlab="Theoretical noise", ylab="Observed noise", main="Plot of observed
         theoretical protein noise")
    dev.off()
}

noise_plot(observed_eta22, theoretical_eta22)

noise_calculator <- function(dat1, dat2, parm){
    tau1 <- 1/parm["beta1"]
    tau2 <- 1/parm["beta2"]
    mRNA_noise <- 1/mean(dat1)
    ex_noise <- mRNA_noise + tau1/(tau1+tau2)
    in_noise <- 1/mean(dat2)
    return(list("Extrinsic" = ex_noise, "Intrinsic" = in_noise))
}

results <- gillespie(x1, x2, iteration, beta1, parameters$beta1, parameters$lambda1, parameters$lambda2)


plot2D <- function(results, x_lim){
    pdf(width = 8, height = 6, "2D.pdf")
    #plot only last epoch
    indeces <- (length(results$x1)- 100000):length(results$x1) 
    
    par(mfrow = c(1,1), mar = c(5,5,5,5))
    plot(results$time[indeces], results$x2[indeces], col = "red", 
         xlim = x_lim, type = "l", ylab = "Protein molecules",
         xlab = "Arbitrary time units",main = "Protein and mRNA levels over time")
    par(new = TRUE)
    plot(results$time[indeces], results$x1[indeces], col = "blue",
         xlim = x_lim, type = "l",
         axes = FALSE, xlab = NA, ylab = NA)
    axis(side = 4)
    mtext(side = 4, line = 3, "mRNA molecules")
    dev.off()
}

plot2D(results)

par(mfrow=c(1,1),mar=c(4,3,1,1))
plot(results$time_keeper[900000:1000000], results$x2_storage[900000:1000000],type="l")
par(new=FALSE)
plot(results$time_keeper[900000:1000000], results$x1_storage[900000:1000000],type="l", col = "red")

##start with small beta1 and large beta2
